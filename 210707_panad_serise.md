

## Pandas 

- 대표적인 데이터 분석 패키지 중 하나
- series, DataFrame등의 자료구조를 활용한 데이터분석 기능을 제공해주는 라이브러리
- 라이브러리 구성
    - 여러종류의 클래스와 다양한 함수로 구성
    - 시리즈와 데이터 프레임의 자료 구조 제공
    - 시리즈(1차원 배열) 데이터프레임(2차원 배열)

## Pands 목적

- 서로 다른 유형의 데이터를 공통된 포맷으로 정리하는 것 (클래스 형태로 구성되어 있음)
- 행과 열로 이루어진 2차원 데이터프레임을 처리 할 수 있는 함수제공 목적
- 실무 사용 형태 : 데이터 프레임 (2차원의 행렬로 구성되어 있음) 

---

## Series

- pandas에서 제공하는 자료구조

  - pandas의 기본 객체 중 하나
  - numpy의 ndarray를 기반으로 인덱싱을 기능을 추가하여 1차원 배열을 나타냄
  - index를 지정하지 않을 시, 기본적으로 ndarray와 같이 0-based 인덱스 생성
  - 지정할 경우 명시적으로 지정된 index를 사용
  - 중요!! 같은 타입의 0개 이상의 데이터를 가질 수 있음



- 자료구조: 시리즈
  - 데이터가 순차적으로 나열된 1차원 배열 형태
  - 인덱스(index)와 데이터 값(value)이 일대일로 대을
  - 딕셔너리와 비슷한 구조 : {key(index):value}

- 시리즈의 인덱스
  - 데이터 값의 위치를 나타내는 이름표 역할

- 시리즈 생성 : 판다스 내장함수인 Series()이용
  - 리스트로 시리즈 만들기
  - 딕셔너리로 시리즈 만들기
  - 튜플로 시리즈 만들기

~~~python
#pandas 패키지(모듈) import
#대부분의 코드에서 pandas pd 라는 별칭으로 사용
import pandas as pd
# numpy 패키지 import 판다를 같이 많이 사용함
import numpy as np
~~~

---

## Series 생성

- 생성 후 입력값을 필요함
- 입력값이 여러 개일 경우 리스트/튜플/딕셔너리 형태로 입력해야 함

~~~python
blank_s = pd.Series() ## 선언 후 data 값을 입력해야함
blank_s #dtype(data) : float64

s0 = pd.Series(1) 
#인덱스 명시하지 않고, 데이터 1개로 생성 -인덱스 0부터 시작하는 0-based 인덱스 생성
s0 # 0:인덱스 1:입력값

# 2개 이상의 원소값을 갖는 시리즈 생성 시 - 리스트, 튜플, 딕셔너리 등을 활용해야 함
s1 = pd.Series([1,2,3]) # 주는 값을 그냥 주면 안됨
s1
# 튜플로 시리즈 만들기
s1_3 = pd.Series((1,2,3))
s1_3
~~~

---

## 다양한 시리즈 생성

- 결측값 포함 생성
  - 결측값 - 값이 정해지지 않은 상태 NULL 의미
  - 결측값은 NaN : numpy라는 모듈의 nan 속성을 통해서 생성 가능 -> na.nan

~~~python
s = pd.Series([1,2,3, np.nan,6,8]) #결측치 NaN은 float로 처리가 됨
~~~

- 인덱스 명시 후  시리즈 생성

~~~python
# 인덱스 명시해서 시리즈 생성 (수치 인덱스)
s = pd.Series([10, 20, 30], index=[1,2,3])

s.index # 인덱스 확인 Int64Index([5, 2, 3], dtype='int64')

# 인덱스 명시해서 시리즈 생성 (문자 인덱스)
s = pd.Series([10, 20, 30], index=['다영', '다혜', '다희'])

s.index # 인덱스 확인 Index(['다영', '다혜', '다희'], dtype='object')
~~~



```python
s= pd.Series([9904312,3448737,289045,2466052],
            index=["서울","부산","인천","대구"]) #dtype='object' datatype = '문자열객체'
s.index
```

```python
Index(['서울', '부산', '인천', '대구'], dtype='object')
```



```python
s.index.name = '도시' # 해당 기능으로 index name 추가 가능

```

```python
도시
서울    9904312
부산    3448737
인천     289045
대구    2466052
dtype: int64
```



- 시리즈.name 속성
  - 시리즈 데이터 (valueds)에 이름을 붙일 수 있음
  - name 속성은 값의 의미 전달에 사용

```
s.name = '인구'
s
```

```
도시
서울    9904312
부산    3448737
인천     289045
대구    2466052
Name: 인구, dtype: int64
```



## 딕셔너리로 생성

##### 딕셔너리로 시리즈 만들기

- Series({key:value,key1:value1....})
- 인덱스 -> key
- 값 -> value
- key가 인덱스로 처리 되므로 명시적으로 인덱스를 설정하게 됨

```
scores = {'홍길동':96, '이몽룡':100, '성춘향':88}
s=pd.Series(scores)
s
```

```
홍길동     96
이몽룡    100
성춘향     88
dtype: int64
```



```
city = {'서울':9631482, '부산':3393191, '인천':2632035, '대전':1490158}
s=pd.Series(city)
s
```

```
서울    9631482
부산    3393191
인천    2632035
대전    1490158
dtype: int64
```

```
### 위에 꺼 인덱스를 추가해서 순서를 표현
s=pd.Series(city, index=['부산', '인천', '서울', '대전'])
s
```

```
부산    3393191
인천    2632035
서울    9631482
대전    1490158
dtype: int64
```

- 딕셔너리의 원소는 순서를 갖지 않음
  - 딕셔너리로 생성된 시리즈의 원소도 순서가 보장되지 않음
  - 만약 순서를 보장하고 싶으면 인덱스를 리스트로 지정

---

### 인데싱

- 데이터에서 특정한 데이터를 추출하는 것

### 시리즈의 인덱싱 종류

1. 정수형 위치 인덱스(integer position)
2. 인덱스 이름(index name) 또는 인덱스 라벨(index label)
   - 인덱스 별도 지정하지 않으면 0부터 시작하는 정수형 인덱스가 지정됨

### 원소 접근

- 정수로 인덱스를 선어한면 위치를 나타내는 인덱스 사용 못함 겹치기 때문

```
- 정수형 인덱스 : 숫자 s[0]
- 문자형 인덱스 : 문자 s['인천']
```

---

## 인덱스 재사용

```
s.index
s1 = pd.Series(np.arange(4), s.index)
s1
```

```
도시
서울    0
부산    1
인천    2
대구    3
dtype: int32
```

---



## Tip

- 한셀에서 동시에 여러 개 실행 가능

```python
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity="last_expr" #(기본값은 'last_expr') 원상태로 돌릴 경우
## 셀안에 있는 모든 것을 동작시키하려는 것
```

---

## 벡터화 연산

- numpy 배열처럼 pandas의 시리즈도 벡터화 연산 가능
- 벡터화 연산이란 집합적 자료형의 원소 각각을 독립적으로 계산을 진행하는 방법
  - 단, 연산은 시리즈의 값에만 적용되며 인덱스 값은 변경 불가

---

## 딕셔너리 와 시리즈의 관계

- 시리즈 객체는 라벨(문자)에 의해 인덱싱이 가능

- 실질적으로는 라벨을 key로 가지는 딕셔너리 형과 같다고 볼 수 있음
- 딕셔너리에서 제공하는 대부분의 연산자 사용 가능
  - in 연산자 : T/F
  - for 루프를 통해 각 원소의 key와 value에 접근 할수 있다.

```
## 딕셔너리의 items()함수 시리즈에서도 사용 가능
s.items()

```

```python
<zip at 0x14c1436ca00> # 리스트를 사용하지 않고 출력하면 zip 형태로 출력
```



```
list(s.items())
```

```
[('서울', 10000000), ('부산', 3448737), ('인천', 289045), ('대구', 2466052)]
```



```pytho
## 반복문을 활용해서 시리즈 각 원소 출력 코드

for k,v in s.items():
    print('%s = %d' %(k,v))
부산 = 3393191
인천 = 2632035
서울 = 10000000
대전 = 1490158
```

---

#### **Series size, shape, unique, count, value_counts 함수**

- size : 개수 반환
- shape : 튜플형태로 shape반환
- unique: 유일한 값만 ndarray로 반환
- count : NaN을 제외한 개수를 반환
- mean: NaN을 제외한 평균
- value_counts: NaN을 제외하고 각 값들의 빈도를 반환